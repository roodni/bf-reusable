let fix = fun f ->
  let g = fun x -> f (fun y -> x x y) in
  g g

let sort = fun compare l ->
  fix
    (fun sort -> fun rest sorted ->
      match rest with
      | nil -> sorted
      | pivot :: rest ->
          fix
            (fun partition -> fun left right l ->
              match l with
              | nil -> sort left (pivot :: sort right sorted)
              | hd :: tl ->
                  if compare hd pivot < 0
                  then partition (hd :: left) right tl
                  else partition left (hd :: right) tl)
            nil nil rest)
    l nil

let gen_del = fun x -> [
  ! x [ - x ]
]

let gen_safe_sub = fun src dest overflow -> [
  ! src [
    - src
    ? dest [ - dest ] [
      *overflow
      *gen_del src
    ]
  ]
]

let gen_switch = fun sel cases default -> [
  $let cases = sort (fun (n1, _) (n2, _) -> n1 - n2) cases
  in
  $var {
    sub_src: cell;
    flag_eq: cell;
    flag_els: cell;
  } in
  *fix
    (fun loop prev cases ->
      match cases with
      | nil -> default
      | (num, block) :: cases -> [
          + sub_src (num - prev)
          + flag_eq
          *gen_safe_sub sub_src sel [ - flag_eq ]
          ? sel [ - flag_eq ] []
          + flag_els
          ! flag_eq [
            - flag_eq
            - flag_els
            *block
          ]
          ! flag_els [
            - flag_els
            *loop num cases
          ]
        ])
    0 cases
]

let gen_puts = fun l -> [
  $var { c: cell; } in
  *fix
    (fun loop prev l ->
      match l with
      | nil -> []
      | hd :: tl -> [
          + c (hd - prev)
          . c
          *loop hd tl
        ])
    0 l
]

main { x: cell; } in
, x

*gen_switch x
  ( ('+', [ *gen_puts "INC" ]);
    ('-', [ *gen_puts "DEC" ]);
    ('.', [ *gen_puts "PUT" ]);
    (',', [ *gen_puts "GET" ]);
    ('[', [ *gen_puts "WHILE" ]);
    (']', [ *gen_puts "WEND" ]);
    ('>', [ *gen_puts "SHR" ]);
    ('<', [ *gen_puts "SHL" ]);
  )
  [ *gen_puts "OTHER" ]